{"ast":null,"code":"import { useCallback, useState } from 'react';\nimport { useNotificationsContext, useTransactionsContext } from '../providers';\nimport { BigNumber, errors } from 'ethers';\nimport { buildSafeTransaction, getLatestNonce } from '../helpers/gnosisSafeUtils';\nimport { useEthers } from './useEthers';\nimport { waitForSafeTransaction } from '../helpers/gnosisSafeUtils';\nimport { useGnosisSafeContract } from './useGnosisSafeContract';\n/**\n * @internal\n */\nexport async function estimateTransactionGasLimit(transactionRequest, signer, gasLimitBufferPercentage) {\n  if (!signer || !transactionRequest) {\n    return undefined;\n  }\n  try {\n    const estimatedGas = transactionRequest.gasLimit ? BigNumber.from(transactionRequest.gasLimit) : await signer.estimateGas(transactionRequest);\n    return estimatedGas === null || estimatedGas === void 0 ? void 0 : estimatedGas.mul(gasLimitBufferPercentage + 100).div(100);\n  } catch (err) {\n    console.error(err);\n    return undefined;\n  }\n}\n/**\n * @internal\n */\nexport async function estimateContractFunctionGasLimit(contractWithSigner, functionName, args, gasLimitBufferPercentage) {\n  try {\n    const estimatedGas = await contractWithSigner.estimateGas[functionName](...args);\n    const gasLimit = estimatedGas === null || estimatedGas === void 0 ? void 0 : estimatedGas.mul(gasLimitBufferPercentage + 100).div(100);\n    return gasLimit;\n  } catch (err) {\n    console.error(err);\n    return undefined;\n  }\n}\n/**\n * @internal\n */\nasync function isNonContractWallet(library, address) {\n  if (!library || !address) {\n    return true;\n  }\n  const code = await library.getCode(address);\n  return code === '0x';\n}\nconst isDroppedAndReplaced = e => (e === null || e === void 0 ? void 0 : e.code) === errors.TRANSACTION_REPLACED && (e === null || e === void 0 ? void 0 : e.replacement) && ((e === null || e === void 0 ? void 0 : e.reason) === 'repriced' || (e === null || e === void 0 ? void 0 : e.cancelled) === false);\nexport function usePromiseTransaction(chainId, options) {\n  const [state, setState] = useState({\n    status: 'None',\n    transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n  });\n  const {\n    addTransaction,\n    updateTransaction\n  } = useTransactionsContext();\n  const {\n    addNotification\n  } = useNotificationsContext();\n  const {\n    library,\n    account\n  } = useEthers();\n  const gnosisSafe = useGnosisSafeContract(account, library);\n  const resetState = useCallback(() => {\n    setState(_ref => {\n      let {\n        transactionName\n      } = _ref;\n      return {\n        status: 'None',\n        transactionName\n      };\n    });\n  }, [setState]);\n  const promiseTransaction = useCallback(async function (transactionPromise) {\n    let {\n      safeTransaction\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let transactionRequest = arguments.length > 2 ? arguments[2] : undefined;\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;\n    const handleNonContractWallet = async transaction => {\n      if (!chainId) return;\n      setState(prevState => Object.assign(Object.assign({}, prevState), {\n        transaction,\n        status: 'Mining'\n      }));\n      addTransaction({\n        transaction: Object.assign(Object.assign({}, transaction), {\n          chainId\n        }),\n        submittedAt: Date.now(),\n        transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n      });\n      const receipt = await transaction.wait();\n      updateTransaction({\n        transaction: Object.assign(Object.assign({}, transaction), {\n          chainId: chainId\n        }),\n        receipt,\n        transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n      });\n      setState({\n        receipt,\n        transaction,\n        status: 'Success',\n        chainId,\n        transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n      });\n      return {\n        transaction,\n        receipt\n      };\n    };\n    const handleContractWallet = async function (transactionPromise) {\n      let {\n        safeTransaction\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _a;\n      if (!chainId || !library || !account) return;\n      setState({\n        status: 'CollectingSignaturePool',\n        chainId,\n        transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n      });\n      const gnosisSafeContract = gnosisSafe.get();\n      if (!gnosisSafeContract) {\n        throw new Error(\"Couldn't create Gnosis Safe contract instance\");\n      }\n      const latestNonce = await getLatestNonce(chainId, account);\n      const safeTx = buildSafeTransaction({\n        to: (_a = safeTransaction === null || safeTransaction === void 0 ? void 0 : safeTransaction.to) !== null && _a !== void 0 ? _a : '',\n        value: safeTransaction === null || safeTransaction === void 0 ? void 0 : safeTransaction.value,\n        data: safeTransaction === null || safeTransaction === void 0 ? void 0 : safeTransaction.data,\n        safeTxGas: safeTransaction === null || safeTransaction === void 0 ? void 0 : safeTransaction.safeTxGas,\n        nonce: latestNonce ? latestNonce + 1 : await gnosisSafeContract.nonce()\n      });\n      const {\n        transaction,\n        receipt,\n        rejected\n      } = await waitForSafeTransaction(transactionPromise, gnosisSafeContract, chainId, safeTx);\n      if (rejected) {\n        const errorMessage = 'On-chain rejection created';\n        addTransaction({\n          transaction: Object.assign(Object.assign({}, transaction), {\n            chainId: chainId\n          }),\n          receipt,\n          submittedAt: Date.now(),\n          transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n        });\n        setState({\n          status: 'Fail',\n          transaction,\n          receipt,\n          errorMessage,\n          chainId,\n          transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n        });\n      } else {\n        addTransaction({\n          transaction: Object.assign(Object.assign({}, transaction), {\n            chainId: chainId\n          }),\n          receipt,\n          submittedAt: Date.now(),\n          transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n        });\n        setState({\n          receipt,\n          transaction,\n          status: 'Success',\n          chainId,\n          transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n        });\n      }\n      return {\n        transaction,\n        receipt\n      };\n    };\n    if (!chainId) return;\n    let transaction = undefined;\n    try {\n      if (options === null || options === void 0 ? void 0 : options.enablePendingSignatureNotification) {\n        setState({\n          status: 'PendingSignature',\n          chainId,\n          transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n        });\n        addNotification({\n          notification: {\n            type: 'transactionPendingSignature',\n            submittedAt: Date.now(),\n            transactionName: options === null || options === void 0 ? void 0 : options.transactionName,\n            transactionRequest\n          },\n          chainId: chainId\n        });\n      }\n      const isContractWallet = !(await isNonContractWallet(library, account));\n      if (isContractWallet) {\n        const result = await handleContractWallet(transactionPromise, {\n          safeTransaction\n        });\n        transaction = result === null || result === void 0 ? void 0 : result.transaction;\n        return result === null || result === void 0 ? void 0 : result.receipt;\n      } else {\n        transaction = await transactionPromise;\n        const result = await handleNonContractWallet(transaction);\n        transaction = result === null || result === void 0 ? void 0 : result.transaction;\n        return result === null || result === void 0 ? void 0 : result.receipt;\n      }\n    } catch (e) {\n      const parsedErrorCode = parseInt((_g = (_e = (_c = (_b = (_a = e.error) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.code) !== null && _c !== void 0 ? _c : (_d = e.error) === null || _d === void 0 ? void 0 : _d.code) !== null && _e !== void 0 ? _e : (_f = e.data) === null || _f === void 0 ? void 0 : _f.code) !== null && _g !== void 0 ? _g : e.code);\n      const errorCode = isNaN(parsedErrorCode) ? undefined : parsedErrorCode;\n      const errorHash = (_l = (_k = (_j = (_h = e === null || e === void 0 ? void 0 : e.error) === null || _h === void 0 ? void 0 : _h.data) === null || _j === void 0 ? void 0 : _j.originalError) === null || _k === void 0 ? void 0 : _k.data) !== null && _l !== void 0 ? _l : (_m = e === null || e === void 0 ? void 0 : e.error) === null || _m === void 0 ? void 0 : _m.data;\n      const errorMessage = (_v = (_t = (_s = (_q = (_p = (_o = e.error) === null || _o === void 0 ? void 0 : _o.data) === null || _p === void 0 ? void 0 : _p.message) !== null && _q !== void 0 ? _q : (_r = e.error) === null || _r === void 0 ? void 0 : _r.message) !== null && _s !== void 0 ? _s : e.reason) !== null && _t !== void 0 ? _t : (_u = e.data) === null || _u === void 0 ? void 0 : _u.message) !== null && _v !== void 0 ? _v : e.message;\n      if (transaction) {\n        const droppedAndReplaced = isDroppedAndReplaced(e);\n        if (droppedAndReplaced) {\n          const status = e.receipt.status === 0 ? 'Fail' : 'Success';\n          const type = status === 'Fail' ? 'transactionFailed' : 'transactionSucceed';\n          addNotification({\n            notification: {\n              type,\n              submittedAt: Date.now(),\n              transaction: e.replacement,\n              receipt: e.receipt,\n              transactionName: (_w = e.replacement) === null || _w === void 0 ? void 0 : _w.transactionName,\n              originalTransaction: transaction\n            },\n            chainId\n          });\n          setState(prevState => {\n            var _a;\n            return Object.assign(Object.assign({}, prevState), {\n              status,\n              transaction: e.replacement,\n              originalTransaction: transaction,\n              receipt: e.receipt,\n              transactionName: (_a = e.replacement) === null || _a === void 0 ? void 0 : _a.transactionName,\n              errorMessage,\n              errorCode,\n              errorHash,\n              chainId\n            });\n          });\n        } else {\n          setState({\n            status: 'Fail',\n            transaction,\n            receipt: e.receipt,\n            errorMessage,\n            errorCode,\n            errorHash,\n            chainId,\n            transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n          });\n        }\n      } else {\n        setState({\n          status: 'Exception',\n          errorMessage,\n          errorCode,\n          errorHash,\n          chainId,\n          transactionName: options === null || options === void 0 ? void 0 : options.transactionName\n        });\n      }\n      return undefined;\n    }\n  }, [chainId, addNotification, options === null || options === void 0 ? void 0 : options.transactionName, library, account]);\n  return {\n    promiseTransaction,\n    state,\n    resetState\n  };\n}","map":{"version":3,"names":["useCallback","useState","useNotificationsContext","useTransactionsContext","BigNumber","errors","buildSafeTransaction","getLatestNonce","useEthers","waitForSafeTransaction","useGnosisSafeContract","estimateTransactionGasLimit","transactionRequest","signer","gasLimitBufferPercentage","undefined","estimatedGas","gasLimit","from","estimateGas","mul","div","err","console","error","estimateContractFunctionGasLimit","contractWithSigner","functionName","args","isNonContractWallet","library","address","code","getCode","isDroppedAndReplaced","e","TRANSACTION_REPLACED","replacement","reason","cancelled","usePromiseTransaction","chainId","options","state","setState","status","transactionName","addTransaction","updateTransaction","addNotification","account","gnosisSafe","resetState","_ref","promiseTransaction","transactionPromise","safeTransaction","arguments","length","handleNonContractWallet","transaction","prevState","Object","assign","submittedAt","Date","now","receipt","wait","handleContractWallet","gnosisSafeContract","get","Error","latestNonce","safeTx","to","_a","value","data","safeTxGas","nonce","rejected","errorMessage","enablePendingSignatureNotification","notification","type","isContractWallet","result","parsedErrorCode","parseInt","_g","_e","_c","_b","_d","_f","errorCode","isNaN","errorHash","_l","_k","_j","_h","originalError","_m","_v","_t","_s","_q","_p","_o","message","_r","_u","droppedAndReplaced","_w","originalTransaction"],"sources":["/Users/mcbood/Desktop/unitest/node_modules/@usedapp/core/src/hooks/usePromiseTransaction.ts"],"sourcesContent":["import type { TransactionRequest, TransactionResponse } from '@ethersproject/abstract-provider'\nimport { useCallback, useState } from 'react'\nimport { useNotificationsContext, useTransactionsContext } from '../providers'\nimport { TransactionStatus, TransactionOptions, TransactionState } from '../model'\nimport { BigNumber, Contract, errors, Signer } from 'ethers'\nimport { buildSafeTransaction, getLatestNonce, SafeTransaction } from '../helpers/gnosisSafeUtils'\nimport { useEthers } from './useEthers'\nimport { waitForSafeTransaction } from '../helpers/gnosisSafeUtils'\nimport { JsonRpcProvider, FallbackProvider } from '@ethersproject/providers'\nimport { useGnosisSafeContract } from './useGnosisSafeContract'\n\ninterface PromiseTransactionOpts {\n  safeTransaction?: Partial<SafeTransaction>\n}\n\n/**\n * @internal\n */\nexport async function estimateTransactionGasLimit(\n  transactionRequest: TransactionRequest | undefined,\n  signer: Signer | undefined,\n  gasLimitBufferPercentage: number\n) {\n  if (!signer || !transactionRequest) {\n    return undefined\n  }\n  try {\n    const estimatedGas = transactionRequest.gasLimit\n      ? BigNumber.from(transactionRequest.gasLimit)\n      : await signer.estimateGas(transactionRequest)\n    return estimatedGas?.mul(gasLimitBufferPercentage + 100).div(100)\n  } catch (err: any) {\n    console.error(err)\n    return undefined\n  }\n}\n\n/**\n * @internal\n */\nexport async function estimateContractFunctionGasLimit(\n  contractWithSigner: Contract,\n  functionName: string,\n  args: any[],\n  gasLimitBufferPercentage: number\n): Promise<BigNumber | undefined> {\n  try {\n    const estimatedGas = await contractWithSigner.estimateGas[functionName](...args)\n    const gasLimit = estimatedGas?.mul(gasLimitBufferPercentage + 100).div(100)\n    return gasLimit\n  } catch (err: any) {\n    console.error(err)\n    return undefined\n  }\n}\n\n/**\n * @internal\n */\nasync function isNonContractWallet(\n  library: JsonRpcProvider | FallbackProvider | undefined,\n  address: string | undefined\n) {\n  if (!library || !address) {\n    return true\n  }\n  const code = await library.getCode(address)\n  return code === '0x'\n}\n\nconst isDroppedAndReplaced = (e: any) =>\n  e?.code === errors.TRANSACTION_REPLACED && e?.replacement && (e?.reason === 'repriced' || e?.cancelled === false)\n\nexport function usePromiseTransaction(chainId: number | undefined, options?: TransactionOptions) {\n  const [state, setState] = useState<TransactionStatus>({ status: 'None', transactionName: options?.transactionName })\n  const { addTransaction, updateTransaction } = useTransactionsContext()\n  const { addNotification } = useNotificationsContext()\n  const { library, account } = useEthers()\n  const gnosisSafe = useGnosisSafeContract(account, library)\n\n  const resetState = useCallback(() => {\n    setState(({ transactionName }) => ({ status: 'None', transactionName }))\n  }, [setState])\n\n  const promiseTransaction = useCallback(\n    async (\n      transactionPromise: Promise<TransactionResponse>,\n      { safeTransaction }: PromiseTransactionOpts = {},\n      transactionRequest?: TransactionRequest\n    ) => {\n      const handleNonContractWallet = async (transaction: TransactionResponse) => {\n        if (!chainId) return\n\n        setState((prevState) => ({ ...prevState, transaction, status: 'Mining' }))\n        addTransaction({\n          transaction: {\n            ...transaction,\n            chainId,\n          },\n          submittedAt: Date.now(),\n          transactionName: options?.transactionName,\n        })\n        const receipt = await transaction.wait()\n        updateTransaction({\n          transaction: {\n            ...transaction,\n            chainId: chainId,\n          },\n          receipt,\n          transactionName: options?.transactionName,\n        })\n        setState({\n          receipt,\n          transaction,\n          status: 'Success',\n          chainId,\n          transactionName: options?.transactionName,\n        })\n        return { transaction, receipt }\n      }\n\n      const handleContractWallet = async (\n        transactionPromise: Promise<TransactionResponse>,\n        { safeTransaction }: PromiseTransactionOpts = {}\n      ) => {\n        if (!chainId || !library || !account) return\n        setState({ status: 'CollectingSignaturePool', chainId, transactionName: options?.transactionName })\n\n        const gnosisSafeContract = gnosisSafe.get()\n        if (!gnosisSafeContract) {\n          throw new Error(\"Couldn't create Gnosis Safe contract instance\")\n        }\n\n        const latestNonce = await getLatestNonce(chainId, account)\n\n        const safeTx = buildSafeTransaction({\n          to: safeTransaction?.to ?? '',\n          value: safeTransaction?.value,\n          data: safeTransaction?.data,\n          safeTxGas: safeTransaction?.safeTxGas,\n          nonce: latestNonce ? latestNonce + 1 : await gnosisSafeContract.nonce(),\n        })\n\n        const { transaction, receipt, rejected } = await waitForSafeTransaction(\n          transactionPromise,\n          gnosisSafeContract,\n          chainId,\n          safeTx\n        )\n\n        if (rejected) {\n          const errorMessage = 'On-chain rejection created'\n          addTransaction({\n            transaction: {\n              ...transaction,\n              chainId: chainId,\n            },\n            receipt,\n            submittedAt: Date.now(),\n            transactionName: options?.transactionName,\n          })\n          setState({\n            status: 'Fail',\n            transaction,\n            receipt,\n            errorMessage,\n            chainId,\n            transactionName: options?.transactionName,\n          })\n        } else {\n          addTransaction({\n            transaction: {\n              ...transaction,\n              chainId: chainId,\n            },\n            receipt,\n            submittedAt: Date.now(),\n            transactionName: options?.transactionName,\n          })\n          setState({\n            receipt,\n            transaction,\n            status: 'Success',\n            chainId,\n            transactionName: options?.transactionName,\n          })\n        }\n        return { transaction, receipt }\n      }\n\n      if (!chainId) return\n      let transaction: TransactionResponse | undefined = undefined\n      try {\n        if (options?.enablePendingSignatureNotification) {\n          setState({ status: 'PendingSignature', chainId, transactionName: options?.transactionName })\n          addNotification({\n            notification: {\n              type: 'transactionPendingSignature',\n              submittedAt: Date.now(),\n              transactionName: options?.transactionName,\n              transactionRequest,\n            },\n            chainId: chainId,\n          })\n        }\n        const isContractWallet = !(await isNonContractWallet(library, account))\n        if (isContractWallet) {\n          const result = await handleContractWallet(transactionPromise, { safeTransaction })\n          transaction = result?.transaction\n          return result?.receipt\n        } else {\n          transaction = await transactionPromise\n          const result = await handleNonContractWallet(transaction)\n          transaction = result?.transaction\n          return result?.receipt\n        }\n      } catch (e: any) {\n        const parsedErrorCode = parseInt(e.error?.data?.code ?? e.error?.code ?? e.data?.code ?? e.code)\n        const errorCode = isNaN(parsedErrorCode) ? undefined : parsedErrorCode\n        const errorHash = e?.error?.data?.originalError?.data ?? e?.error?.data\n        const errorMessage = e.error?.data?.message ?? e.error?.message ?? e.reason ?? e.data?.message ?? e.message\n        if (transaction) {\n          const droppedAndReplaced = isDroppedAndReplaced(e)\n\n          if (droppedAndReplaced) {\n            const status: TransactionState = e.receipt.status === 0 ? 'Fail' : 'Success'\n            const type = status === 'Fail' ? 'transactionFailed' : 'transactionSucceed'\n\n            addNotification({\n              notification: {\n                type,\n                submittedAt: Date.now(),\n                transaction: e.replacement,\n                receipt: e.receipt,\n                transactionName: e.replacement?.transactionName,\n                originalTransaction: transaction,\n              },\n              chainId,\n            })\n\n            setState((prevState) => ({\n              ...prevState,\n              status,\n              transaction: e.replacement,\n              originalTransaction: transaction,\n              receipt: e.receipt,\n              transactionName: e.replacement?.transactionName,\n              errorMessage,\n              errorCode,\n              errorHash,\n              chainId,\n            }))\n          } else {\n            setState({\n              status: 'Fail',\n              transaction,\n              receipt: e.receipt,\n              errorMessage,\n              errorCode,\n              errorHash,\n              chainId,\n              transactionName: options?.transactionName,\n            })\n          }\n        } else {\n          setState({\n            status: 'Exception',\n            errorMessage,\n            errorCode,\n            errorHash,\n            chainId,\n            transactionName: options?.transactionName,\n          })\n        }\n        return undefined\n      }\n    },\n    [chainId, addNotification, options?.transactionName, library, account]\n  )\n\n  return { promiseTransaction, state, resetState }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}