{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useReducer, useState } from 'react';\nimport { providers } from 'ethers';\nimport { useConfig } from '../../../hooks';\nimport { ReadonlyNetworksContext } from './context';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { networkStatesReducer } from './reducer';\nimport { useWindow } from '../../window';\nimport { isWebSocketProvider } from '../../../helpers';\nconst {\n  Provider,\n  StaticJsonRpcProvider\n} = providers;\nconst getProviderFromConfig = urlOrProviderOrProviderFunction => {\n  if (Provider.isProvider(urlOrProviderOrProviderFunction)) {\n    return urlOrProviderOrProviderFunction;\n  }\n  if (typeof urlOrProviderOrProviderFunction === 'function') {\n    return urlOrProviderOrProviderFunction();\n  }\n  return new StaticJsonRpcProvider(urlOrProviderOrProviderFunction);\n};\nexport const getProvidersFromConfig = readOnlyUrls => fromEntries(Object.entries(readOnlyUrls).map(_ref => {\n  let [chainId, urlOrProviderOrProviderFunction] = _ref;\n  return [chainId, getProviderFromConfig(urlOrProviderOrProviderFunction)];\n}));\nexport function ReadonlyNetworksProvider(_ref2) {\n  let {\n    providerOverrides = {},\n    children\n  } = _ref2;\n  const {\n    readOnlyUrls = {},\n    pollingInterval,\n    pollingIntervals\n  } = useConfig();\n  const isActive = useWindow();\n  const [providers, setProviders] = useState(() => Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n  const [networkStates, dispatchNetworkState] = useReducer(networkStatesReducer, Object.assign({}, fromEntries(Object.keys(Object.assign(Object.assign({}, readOnlyUrls), providerOverrides)).map(chainId => [chainId, {\n    errors: []\n  }]))));\n  const getPollingInterval = useCallback(chainId => {\n    var _a;\n    return (_a = pollingIntervals === null || pollingIntervals === void 0 ? void 0 : pollingIntervals[chainId]) !== null && _a !== void 0 ? _a : pollingInterval;\n  }, [pollingInterval, pollingIntervals]);\n  useEffect(() => {\n    setProviders(Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n  }, Object.entries(readOnlyUrls).flat());\n  useEffect(() => {\n    for (const [chainId] of Object.entries(readOnlyUrls)) {\n      const provider = providers[chainId];\n      if (provider && !isWebSocketProvider(provider)) {\n        provider.polling = isActive;\n      }\n    }\n  }, [isActive, providers, readOnlyUrls]);\n  useEffect(() => {\n    for (const [chainId, provider] of Object.entries(providers)) {\n      if (!isWebSocketProvider(provider)) {\n        provider.pollingInterval = getPollingInterval(Number(chainId));\n      }\n    }\n  }, [providers, getPollingInterval]);\n  const networks = useMemo(() => ({\n    providers,\n    updateNetworkState: dispatchNetworkState,\n    networkStates\n  }), [providers, dispatchNetworkState, networkStates]);\n  return _jsx(ReadonlyNetworksContext.Provider, Object.assign({\n    value: networks\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"names":["useCallback","useEffect","useMemo","useReducer","useState","providers","useConfig","ReadonlyNetworksContext","fromEntries","networkStatesReducer","useWindow","isWebSocketProvider","Provider","StaticJsonRpcProvider","getProviderFromConfig","urlOrProviderOrProviderFunction","isProvider","getProvidersFromConfig","readOnlyUrls","Object","entries","map","_ref","chainId","ReadonlyNetworksProvider","_ref2","providerOverrides","children","pollingInterval","pollingIntervals","isActive","setProviders","assign","networkStates","dispatchNetworkState","keys","errors","getPollingInterval","_a","flat","provider","polling","Number","networks","updateNetworkState","_jsx","value"],"sources":["/Users/mcbood/Desktop/unitestask/node_modules/@usedapp/core/src/providers/network/readonlyNetworks/provider.tsx"],"sourcesContent":["import { ReactNode, useCallback, useEffect, useMemo, useReducer, useState } from 'react'\nimport { providers } from 'ethers'\nimport { useConfig } from '../../../hooks'\nimport { Providers } from './model'\nimport { ReadonlyNetworksContext } from './context'\nimport { BaseProviderFactory, ChainId, NodeUrls } from '../../../constants'\nimport { fromEntries } from '../../../helpers/fromEntries'\nimport { networkStatesReducer } from './reducer'\nimport { useWindow } from '../../window'\nimport { isWebSocketProvider } from '../../../helpers'\n\nconst { Provider, StaticJsonRpcProvider } = providers\ntype BaseProvider = providers.BaseProvider\n\ninterface NetworkProviderProps {\n  providerOverrides?: Providers\n  children?: ReactNode\n}\n\nconst getProviderFromConfig = (urlOrProviderOrProviderFunction: string | BaseProvider | BaseProviderFactory) => {\n  if (Provider.isProvider(urlOrProviderOrProviderFunction)) {\n    return urlOrProviderOrProviderFunction\n  }\n  if (typeof urlOrProviderOrProviderFunction === 'function') {\n    return urlOrProviderOrProviderFunction()\n  }\n  return new StaticJsonRpcProvider(urlOrProviderOrProviderFunction)\n}\n\nexport const getProvidersFromConfig = (readOnlyUrls: NodeUrls) =>\n  fromEntries(\n    Object.entries(readOnlyUrls).map(([chainId, urlOrProviderOrProviderFunction]) => [\n      chainId,\n      getProviderFromConfig(urlOrProviderOrProviderFunction),\n    ])\n  )\n\nexport function ReadonlyNetworksProvider({ providerOverrides = {}, children }: NetworkProviderProps) {\n  const { readOnlyUrls = {}, pollingInterval, pollingIntervals } = useConfig()\n  const isActive = useWindow()\n  const [providers, setProviders] = useState<Providers>(() => ({\n    ...getProvidersFromConfig(readOnlyUrls),\n    ...providerOverrides,\n  }))\n  const [networkStates, dispatchNetworkState] = useReducer(networkStatesReducer, {\n    ...fromEntries(Object.keys({ ...readOnlyUrls, ...providerOverrides }).map((chainId) => [chainId, { errors: [] }])),\n  })\n  const getPollingInterval = useCallback((chainId: number) => pollingIntervals?.[chainId] ?? pollingInterval, [\n    pollingInterval,\n    pollingIntervals,\n  ])\n\n  useEffect(() => {\n    setProviders({ ...getProvidersFromConfig(readOnlyUrls), ...providerOverrides })\n  }, Object.entries(readOnlyUrls).flat())\n\n  useEffect(() => {\n    for (const [chainId] of Object.entries(readOnlyUrls)) {\n      const provider = providers[(chainId as unknown) as ChainId]\n      if (provider && !isWebSocketProvider(provider)) {\n        provider.polling = isActive\n      }\n    }\n  }, [isActive, providers, readOnlyUrls])\n\n  useEffect(() => {\n    for (const [chainId, provider] of Object.entries(providers)) {\n      if (!isWebSocketProvider(provider)) {\n        provider.pollingInterval = getPollingInterval(Number(chainId))\n      }\n    }\n  }, [providers, getPollingInterval])\n\n  const networks = useMemo(\n    () => ({\n      providers,\n      updateNetworkState: dispatchNetworkState,\n      networkStates,\n    }),\n    [providers, dispatchNetworkState, networkStates]\n  )\n\n  return <ReadonlyNetworksContext.Provider value={networks}>{children}</ReadonlyNetworksContext.Provider>\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}