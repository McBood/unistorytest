{"ast":null,"code":"import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { useEffect, useState } from 'react';\nimport { utils } from 'ethers';\nimport { getChainById } from '../helpers';\nimport { useEthers, useBlockNumber, useConfig, useUpdateConfig, useLocalStorage } from '../hooks';\nimport multicallABI from '../constants/abi/MultiCall.json';\nimport multicall2ABI from '../constants/abi/MultiCall2.json';\nimport { deployContract } from '../helpers/contract';\nvar LocalMulticallState;\n(function (LocalMulticallState) {\n  LocalMulticallState[LocalMulticallState[\"Unknown\"] = 0] = \"Unknown\";\n  LocalMulticallState[LocalMulticallState[\"NonLocal\"] = 1] = \"NonLocal\";\n  LocalMulticallState[LocalMulticallState[\"Deploying\"] = 2] = \"Deploying\";\n  LocalMulticallState[LocalMulticallState[\"Deployed\"] = 3] = \"Deployed\";\n  LocalMulticallState[LocalMulticallState[\"Error\"] = 4] = \"Error\";\n})(LocalMulticallState || (LocalMulticallState = {}));\nexport function LocalMulticallProvider(_ref) {\n  let {\n    children\n  } = _ref;\n  const updateConfig = useUpdateConfig();\n  const {\n    library,\n    chainId\n  } = useEthers();\n  const [, setMulticallAddress, getCurrent] = useLocalStorage('local_multicall_address' + chainId);\n  const {\n    multicallAddresses,\n    multicallVersion\n  } = useConfig();\n  const [localMulticallState, setLocalMulticallState] = useState(LocalMulticallState.Unknown);\n  const [multicallBlockNumber, setMulticallBlockNumber] = useState();\n  const blockNumber = useBlockNumber();\n  useEffect(() => {\n    var _a;\n    if (!library || !chainId) {\n      setLocalMulticallState(LocalMulticallState.Unknown);\n    } else if (!((_a = getChainById(chainId)) === null || _a === void 0 ? void 0 : _a.isLocalChain)) {\n      setLocalMulticallState(LocalMulticallState.NonLocal);\n    } else if (multicallAddresses && multicallAddresses[chainId]) {\n      setLocalMulticallState(LocalMulticallState.Deployed);\n    } else if (localMulticallState !== LocalMulticallState.Deploying) {\n      const checkDeployed = async () => {\n        const multicallAddress = getCurrent();\n        if (typeof multicallAddress === 'string' && utils.isAddress(multicallAddress)) {\n          const multicallCode = await library.getCode(multicallAddress);\n          if (multicallCode !== '0x') {\n            updateConfig({\n              multicallAddresses: {\n                [chainId]: multicallAddress\n              }\n            });\n            return;\n          }\n        }\n        const signer = library && 'getSigner' in library ? library.getSigner() : undefined;\n        if (!signer) {\n          setLocalMulticallState(LocalMulticallState.Error);\n          return;\n        }\n        setLocalMulticallState(LocalMulticallState.Deploying);\n        const deployMulticall = async () => {\n          try {\n            const {\n              contractAddress,\n              blockNumber\n            } = await deployContract(multicallVersion === 1 ? multicallABI : multicall2ABI, signer);\n            updateConfig({\n              multicallAddresses: {\n                [chainId]: contractAddress\n              }\n            });\n            setMulticallAddress(contractAddress);\n            setMulticallBlockNumber(blockNumber);\n            setLocalMulticallState(LocalMulticallState.Deployed);\n          } catch (_a) {\n            setLocalMulticallState(LocalMulticallState.Error);\n          }\n        };\n        void deployMulticall();\n      };\n      void checkDeployed();\n    }\n  }, [library, chainId]);\n  const awaitingMulticallBlock = multicallBlockNumber && blockNumber && blockNumber < multicallBlockNumber;\n  if (localMulticallState === LocalMulticallState.Deploying || localMulticallState === LocalMulticallState.Deployed && awaitingMulticallBlock) {\n    return _jsx(\"div\", {\n      children: \"Deploying multicall...\"\n    });\n  } else if (localMulticallState === LocalMulticallState.Error) {\n    return _jsx(\"div\", {\n      children: \"Error deploying multicall contract\"\n    });\n  } else {\n    return _jsx(_Fragment, {\n      children: children\n    });\n  }\n}","map":{"version":3,"names":["useEffect","useState","utils","getChainById","useEthers","useBlockNumber","useConfig","useUpdateConfig","useLocalStorage","multicallABI","multicall2ABI","deployContract","LocalMulticallState","LocalMulticallProvider","_ref","children","updateConfig","library","chainId","setMulticallAddress","getCurrent","multicallAddresses","multicallVersion","localMulticallState","setLocalMulticallState","Unknown","multicallBlockNumber","setMulticallBlockNumber","blockNumber","_a","isLocalChain","NonLocal","Deployed","Deploying","checkDeployed","multicallAddress","isAddress","multicallCode","getCode","signer","getSigner","undefined","Error","deployMulticall","contractAddress","awaitingMulticallBlock","_jsx","_Fragment"],"sources":["/Users/mcbood/Desktop/unitest/node_modules/@usedapp/core/src/providers/LocalMulticallProvider.tsx"],"sourcesContent":["import { ReactNode, useEffect, useState } from 'react'\nimport { utils } from 'ethers'\nimport { getChainById } from '../helpers'\nimport { useEthers, useBlockNumber, useConfig, useUpdateConfig, useLocalStorage } from '../hooks'\nimport multicallABI from '../constants/abi/MultiCall.json'\nimport multicall2ABI from '../constants/abi/MultiCall2.json'\nimport { deployContract } from '../helpers/contract'\n\ninterface LocalMulticallProps {\n  children: ReactNode\n}\n\nenum LocalMulticallState {\n  Unknown,\n  NonLocal,\n  Deploying,\n  Deployed,\n  Error,\n}\n\nexport function LocalMulticallProvider({ children }: LocalMulticallProps) {\n  const updateConfig = useUpdateConfig()\n  const { library, chainId } = useEthers()\n  const [, setMulticallAddress, getCurrent] = useLocalStorage('local_multicall_address' + chainId)\n\n  const { multicallAddresses, multicallVersion } = useConfig()\n  const [localMulticallState, setLocalMulticallState] = useState(LocalMulticallState.Unknown)\n  const [multicallBlockNumber, setMulticallBlockNumber] = useState<number>()\n  const blockNumber = useBlockNumber()\n\n  useEffect(() => {\n    if (!library || !chainId) {\n      setLocalMulticallState(LocalMulticallState.Unknown)\n    } else if (!getChainById(chainId)?.isLocalChain) {\n      setLocalMulticallState(LocalMulticallState.NonLocal)\n    } else if (multicallAddresses && multicallAddresses[chainId]) {\n      setLocalMulticallState(LocalMulticallState.Deployed)\n    } else if (localMulticallState !== LocalMulticallState.Deploying) {\n      const checkDeployed = async () => {\n        const multicallAddress = getCurrent()\n\n        if (typeof multicallAddress === 'string' && utils.isAddress(multicallAddress)) {\n          const multicallCode = await library.getCode(multicallAddress)\n          if (multicallCode !== '0x') {\n            updateConfig({ multicallAddresses: { [chainId]: multicallAddress } })\n            return\n          }\n        }\n\n        const signer = library && 'getSigner' in library ? library.getSigner() : undefined\n        if (!signer) {\n          setLocalMulticallState(LocalMulticallState.Error)\n          return\n        }\n\n        setLocalMulticallState(LocalMulticallState.Deploying)\n\n        const deployMulticall = async () => {\n          try {\n            const { contractAddress, blockNumber } = await deployContract(\n              multicallVersion === 1 ? multicallABI : multicall2ABI,\n              signer\n            )\n            updateConfig({ multicallAddresses: { [chainId]: contractAddress } })\n            setMulticallAddress(contractAddress)\n            setMulticallBlockNumber(blockNumber)\n            setLocalMulticallState(LocalMulticallState.Deployed)\n          } catch {\n            setLocalMulticallState(LocalMulticallState.Error)\n          }\n        }\n        void deployMulticall()\n      }\n      void checkDeployed()\n    }\n  }, [library, chainId])\n\n  const awaitingMulticallBlock = multicallBlockNumber && blockNumber && blockNumber < multicallBlockNumber\n\n  if (\n    localMulticallState === LocalMulticallState.Deploying ||\n    (localMulticallState === LocalMulticallState.Deployed && awaitingMulticallBlock)\n  ) {\n    return <div>Deploying multicall...</div>\n  } else if (localMulticallState === LocalMulticallState.Error) {\n    return <div>Error deploying multicall contract</div>\n  } else {\n    return <>{children}</>\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}