{"ast":null,"code":"import { utils } from 'ethers';\nimport { defaultMulticall1ErrorMessage } from '../abi/multicall/constants';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function warnOnInvalidCall(call) {\n  if (!call) {\n    return;\n  }\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function validateCall(call) {\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  if (!contract.address || !method) {\n    throw new Error('Missing contract address or method name');\n  }\n  try {\n    contract.interface.encodeFunctionData(method, args);\n    return call;\n  } catch (err) {\n    throw new Error(`Invalid contract call for method=\"${method}\" on contract=\"${contract.address}\": ${err.message}`);\n  }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n * @returns\n * One of these:\n * - a RawCall, if encoding is successful.\n * - Falsy, if there is no call to encode.\n * - an Error, if encoding fails (e.g. because of mismatched arguments).\n */\nexport function encodeCallData(call, chainId) {\n  let queryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a;\n  if (!call) {\n    return undefined;\n  }\n  try {\n    validateCall(call);\n  } catch (e) {\n    return e;\n  }\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  const isStatic = (_a = queryParams.isStatic) !== null && _a !== void 0 ? _a : queryParams.refresh === 'never';\n  const refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined;\n  return {\n    address: contract.address,\n    data: contract.interface.encodeFunctionData(method, args),\n    chainId,\n    isStatic,\n    refreshPerBlocks\n  };\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getUniqueActiveCalls(requests) {\n  const unique = [];\n  const used = {};\n  for (const request of requests) {\n    if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n      unique.push(request);\n      used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true;\n    }\n  }\n  return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getCallsForUpdate(requests, options) {\n  const callsForUpdate = [];\n  for (const request of requests) {\n    if (options) {\n      if (options.chainId && options.chainId !== request.chainId) {\n        continue;\n      }\n      if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n        continue;\n      }\n      const currentBlock = options.blockNumber;\n      if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n        if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n          continue;\n        }\n      }\n    }\n    callsForUpdate.push(request);\n  }\n  return callsForUpdate;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function decodeCallResult(call, result) {\n  var _a;\n  if (!result || !call) {\n    return undefined;\n  }\n  const {\n    value,\n    success\n  } = result;\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value),\n        error: undefined\n      };\n    } else {\n      const errorMessage = (_a = tryDecodeErrorData(value, call.contract.interface)) !== null && _a !== void 0 ? _a : 'Unknown error';\n      return {\n        value: undefined,\n        error: new Error(errorMessage)\n      };\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error\n    };\n  }\n}\nfunction tryDecodeErrorData(data, contractInterface) {\n  if (data === '0x') {\n    return 'Call reverted without a cause message';\n  }\n  if (data.startsWith('0x08c379a0')) {\n    // decode Error(string)\n    const reason = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', data)[0];\n    if (reason.startsWith('VM Exception')) {\n      return defaultMulticall1ErrorMessage;\n    }\n    return reason;\n  }\n  if (data.startsWith('0x4e487b71')) {\n    // decode Panic(uint)\n    const code = new utils.Interface(['function Panic(uint)']).decodeFunctionData('Panic', data)[0];\n    return `panic code ${code._hex}`;\n  }\n  try {\n    const errorInfo = contractInterface.parseError(data);\n    return `error ${errorInfo.name}`;\n  } catch (e) {\n    console.error(e);\n  }\n}","map":{"version":3,"names":["utils","defaultMulticall1ErrorMessage","warnOnInvalidCall","call","contract","method","args","console","warn","address","validateCall","Error","interface","encodeFunctionData","err","message","encodeCallData","chainId","queryParams","arguments","length","undefined","e","isStatic","_a","refresh","refreshPerBlocks","data","getUniqueActiveCalls","requests","unique","used","request","toLowerCase","push","getCallsForUpdate","options","callsForUpdate","lastUpdatedBlockNumber","currentBlock","blockNumber","decodeCallResult","result","value","success","decodeFunctionResult","error","errorMessage","tryDecodeErrorData","contractInterface","startsWith","reason","Interface","decodeFunctionData","code","_hex","errorInfo","parseError","name"],"sources":["/Users/mcbood/Desktop/unitestask/node_modules/@usedapp/core/src/helpers/calls.ts"],"sourcesContent":["import { BigNumber, utils } from 'ethers'\nimport { Call } from '../hooks/useCall'\nimport { Awaited, ContractMethodNames, Falsy, TypedContract } from '../model/types'\nimport { RawCall, RawCallResult } from '../providers'\nimport { QueryParams } from '../constants/type/QueryParams'\nimport { ChainId } from '../constants/chainId'\nimport { defaultMulticall1ErrorMessage } from '../abi/multicall/constants'\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function warnOnInvalidCall(call: Call | Falsy) {\n  if (!call) {\n    return\n  }\n  const { contract, method, args } = call\n  console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`)\n}\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function validateCall(call: Call): Call {\n  const { contract, method, args } = call\n  if (!contract.address || !method) {\n    throw new Error('Missing contract address or method name')\n  }\n\n  try {\n    contract.interface.encodeFunctionData(method, args)\n    return call\n  } catch (err: any) {\n    throw new Error(`Invalid contract call for method=\"${method}\" on contract=\"${contract.address}\": ${err.message}`)\n  }\n}\n\n/**\n * @internal Intended for internal use - use it on your own risk\n * @returns\n * One of these:\n * - a RawCall, if encoding is successful.\n * - Falsy, if there is no call to encode.\n * - an Error, if encoding fails (e.g. because of mismatched arguments).\n */\nexport function encodeCallData(\n  call: Call | Falsy,\n  chainId: number,\n  queryParams: QueryParams = {}\n): RawCall | Falsy | Error {\n  if (!call) {\n    return undefined\n  }\n  try {\n    validateCall(call)\n  } catch (e: any) {\n    return e\n  }\n  const { contract, method, args } = call\n  const isStatic = queryParams.isStatic ?? queryParams.refresh === 'never'\n  const refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined\n\n  return {\n    address: contract.address,\n    data: contract.interface.encodeFunctionData(method, args),\n    chainId,\n    isStatic,\n    refreshPerBlocks,\n  }\n}\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getUniqueActiveCalls(requests: RawCall[]) {\n  const unique: RawCall[] = []\n  const used: Record<string, boolean> = {}\n  for (const request of requests) {\n    if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n      unique.push(request)\n      used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true\n    }\n  }\n  return unique\n}\n\nexport interface RefreshOptions {\n  blockNumber?: number\n  chainId?: ChainId\n}\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getCallsForUpdate(requests: RawCall[], options?: RefreshOptions) {\n  const callsForUpdate: RawCall[] = []\n  for (const request of requests) {\n    if (options) {\n      if (options.chainId && options.chainId !== request.chainId) {\n        continue\n      }\n      if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n        continue\n      }\n      const currentBlock = options.blockNumber\n      if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n        if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n          continue\n        }\n      }\n    }\n    callsForUpdate.push(request)\n  }\n  return callsForUpdate\n}\n\n/**\n * Result of a {@link useCall} query.\n *\n * It is `undefined` when call didn't return yet or a object `{ value, error }` if it did.\n *\n * - `value:` `any[] | undefined` - array of results or undefined if error occurred,\n * - `error`: `Error | undefined` - encountered error or undefined if call was successful.\n *\n * @public\n */\nexport type CallResult<T extends TypedContract, MN extends ContractMethodNames<T>> =\n  | { value: Awaited<ReturnType<T['functions'][MN]> | undefined>; error: Error | undefined }\n  | undefined\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function decodeCallResult<T extends TypedContract, MN extends ContractMethodNames<T>>(\n  call: Call | Falsy,\n  result: RawCallResult\n): CallResult<T, MN> {\n  if (!result || !call) {\n    return undefined\n  }\n  const { value, success } = result\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value) as Awaited<\n          ReturnType<T['functions'][MN]>\n        >,\n        error: undefined,\n      }\n    } else {\n      const errorMessage: string = tryDecodeErrorData(value, call.contract.interface) ?? 'Unknown error'\n      return {\n        value: undefined,\n        error: new Error(errorMessage),\n      }\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error as Error,\n    }\n  }\n}\n\nfunction tryDecodeErrorData(data: string, contractInterface: utils.Interface): string | undefined {\n  if (data === '0x') {\n    return 'Call reverted without a cause message'\n  }\n\n  if (data.startsWith('0x08c379a0')) {\n    // decode Error(string)\n    const reason: string = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', data)[0]\n    if (reason.startsWith('VM Exception')) {\n      return defaultMulticall1ErrorMessage\n    }\n    return reason\n  }\n\n  if (data.startsWith('0x4e487b71')) {\n    // decode Panic(uint)\n    const code: BigNumber = new utils.Interface(['function Panic(uint)']).decodeFunctionData('Panic', data)[0]\n    return `panic code ${code._hex}`\n  }\n\n  try {\n    const errorInfo = contractInterface.parseError(data)\n    return `error ${errorInfo.name}`\n  } catch (e) {\n    console.error(e)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}